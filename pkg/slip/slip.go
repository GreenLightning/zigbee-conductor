// Implements Serial Line IP as specified in RFC 1055.
// Comments in quotes are from the RFC.
// See: https://datatracker.ietf.org/doc/html/rfc1055
package slip

import (
	"bytes"
	"io"
)

const (
	END     = 0300 // 0xC0, "indicates end of packet"
	ESC     = 0333 // 0xDB, "indicates byte stuffing"
	ESC_END = 0334 // 0xDC, "ESC ESC_END means END data byte"
	ESC_ESC = 0335 // 0xDD, "ESC ESC_ESC means ESC data byte"
)

func WritePacket(writer io.Writer, packet []byte) error {
	var buffer bytes.Buffer

	// Ensure space for the packet and leading / trailing END characters.
	// This is an underestimation as it ignores byte stuffing.
	buffer.Grow(len(packet) + 2)

	// Packets are usually prefixed with an END character. The RFC comments:
	// "send an initial END character to flush out any data that may have
	// accumulated in the receiver due to line noise"
	buffer.WriteByte(END)

	for _, value := range packet {
		switch value {
		case END:
			buffer.WriteByte(ESC)
			buffer.WriteByte(ESC_END)

		case ESC:
			buffer.WriteByte(ESC)
			buffer.WriteByte(ESC_ESC)

		default:
			buffer.WriteByte(value)
		}
	}

	buffer.WriteByte(END)

	_, err := writer.Write(buffer.Bytes())
	return err
}

// ReadPacket reads a full packet from reader.
//
// On error, any partially read packet data is dropped.
//
// @Note: This calls reader.Read() for each byte. If this is not desired, the
// reader can be wrapped using bufio.NewReader().
func ReadPacket(reader io.Reader) ([]byte, error) {
	var buffer bytes.Buffer
	for {
		byte, err := readByte(reader)
		if err != nil {
			return nil, err
		}

		switch byte {
		case END:
			// "If there is no data in the packet, ignore it. This is meant to
			// avoid bothering IP with all the empty packets generated by the
			// duplicate END characters which are in turn sent to try to detect
			// line noise."
			if buffer.Len() == 0 {
				continue
			}

			return buffer.Bytes(), nil

		case ESC:
			next, err := readByte(reader)
			if err != nil {
				return nil, err
			}

			switch next {
			case ESC_END:
				buffer.WriteByte(END)
			case ESC_ESC:
				buffer.WriteByte(ESC)
			default:
				// This is a protocol violation. From the RFC: "The best bet
				// seems to be to leave the byte alone and just stuff it into
				// the packet."
				buffer.WriteByte(next)
			}

		default:
			buffer.WriteByte(byte)
		}
	}
}

// readByte reads a single byte from reader.
//
// This function either returns a valid data byte or an error, but never both.
// If the underlying reader returns both data and an error, the error is dropped.
// We assume that the reader will return just the error on the next call.
func readByte(reader io.Reader) (byte, error) {
	// @Note: There is also io.ByteReader, which has a very nice interface, but
	// bufio.Reader, which is probably the most commonly used implementation,
	// has a hardcoded limit on the number of empty reads. This does not play
	// well with serial port implementations that immediately return if no data
	// is available, so we do not want to use this interface here. Note that
	// bufio.Reader.Read() has a different contract and performs at most one
	// read from the underlying reader and is therefor perfectly applicable.
	var buffer [1]byte
	_, err := io.ReadFull(reader, buffer[:])
	return buffer[0], err
}
